---
layout: post
title: "微服务设计 - 读书摘要"
---

# 微服务设计 - 读书摘要

微服务的概念已经火了好几年了，这本Sam Newman写的《Building Microservices》就是微服务领域最为有名的著作。

## 没有银弹

和所有其他技术一样，我们必须清醒地认识到没有一种方案是能解决一切问题的。微服务也是如此。

微服务能够达到的优点有：

- 异构系统：不同模块可以采用不一样的技术栈
- 灵活扩展
- 舱壁：非级联故障可以保证系统其它模块仍然工作
- 高效开发和部署

## 定义微服务

什么样的服务是好服务？我们可以有两个通用的准则：低耦合，高内聚。

- 低耦合：能够独立修改及部署单个服务而不需要修改系统其它部分。服务之间的接口应该越少越好，否则就有增加耦合度的风险。
- 高内聚：把相关行为聚集在一起，把不相关的行为放在别处。对于强耦合的行为，应该尽量放在一个地方方便修改和发布。

领域驱动设计可以帮助找到微服务的划分方法。领域驱动设计根据业务分割成不同的领域，每个领域有自己的边界。限界上下文是一个由边界限定的特定职责。如果想要从一个限界上下文获取信息，或者发起请求，必须使用指定的模型和它的边界进行通信。不同限界上下文可以把对方视为黑盒子。这些限界上下文就可以对应到不同的微服务。

不应该过早的进行微服务的划分。在系统搭建的早期，由于对业务的熟悉程度不够或者业务本身发展速度很快，服务之间的边界并不会很稳定。如果微服务的边界划分有问题，后期修复代价会非常大。所以刚开始可以使用一段时间的单体系统，等到系统稳定以后再进行微服务的划分。微服务的划分也可以是逐步进行的。

应该避免根据数据本身进行划分。如果只考虑模型，就会搭建一些只包含CRUD功能的数据服务。这样的抽象或者没有必要，或者会增加不同服务之间的耦合性。

另一个需要注意的是不能根据技术层次来进行划分。按技术层次划分，往往会导致不同业务逻辑在共享数据层的耦合。

## 微服务的集成

### 接口

微服务之间的接口应该遵守：

- 避免破坏性修改
- API的技术无关性
- 便于消费方使用
- 隐藏内部细节

### 通信与协作方式

服务之间的通信方式可以是同步或者异步的。同步通信简单并且可以确定事情到底成功与否。异步通信更适用于长时间运行的任务。同步通信往往是请求/响应的模式。异步通信也可以使用请求/响应的模式：在发起请求时注册一个回调，当服务端操作结束时，会调用该回调。异步通信还可以基于事件。客户端发布一个事件，订阅者根据事件做出响应。

从业务的角度来说，微服务之间的协作方式可以是编排的或者是协同的。

- 编排：某个中心服务掌控一系列的业务流程，往往可以用同步调用实现。编排方式很容易可以知道整个业务流程的工作是否正常。缺点是该服务会成为一个中心结点承担了过多的职责，可能会导致下游的服务沦为基于CRUD的服务。
- 协同：不存在中心服务，每个服务根据事件做出响应。可以很灵活地增加订阅者。协同可以减少整个系统的耦合度。缺点是看不到明显的业务流程。还需要做额外的工作监控整个流程。

请求/响应的模式可以用RPC或者REST实现。REST会一定程度上引入客户端和服务端的耦合性。一个可以借鉴的原则是"HATEOAS"（超媒体作为程序状态的引擎）。

基于事件的异步协作方式有两个部分需要考虑：微服务发布事件机制和消费者接收事件机制。

### 代码重用

为了避免耦合，跨服务的情况下可以适当违反DRY原则。

客户端库应该只包含处理底层传输协议的代码，比如服务发现和故障处理等。不要把与目标服务相关的逻辑放到客户端库。

### 按引用访问

某个微服务可能是相关信息的唯一可靠来源。为了得到准确的信息，需要每次都访问该服务。但是，避免不必要的数据请求可以让系统更高效。

在考虑基于事件的协作时，不仅需要知道事件发生，还需要知道到底发生了什么。为了能够在处理事件时得到资源的最新状态，事件应该包含该实体的引用便于查询。如果查询负载过大，可以考虑由相关的缓存来优化。

### 版本管理

- 尽可能不进行破坏性修改
- 及早发现
- 语义化版本管理
- 不同版本接口共存

## 部署

## 测试

## 监控

## 安全

## 规模化

## 链接

- [Building Microservices](https://learning.oreilly.com/library/view/building-microservices/9781491950340/)